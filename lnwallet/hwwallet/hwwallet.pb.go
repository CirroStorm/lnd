// Code generated by protoc-gen-go. DO NOT EDIT.
// source: hwwallet.proto

/*
Package hwwallet is a generated protocol buffer package.

It is generated from these files:
	hwwallet.proto

It has these top-level messages:
	OutPoint
	TxIn
	TxOut
	MsgTx
	SendOutputsRequest
	SendOutputsResponse
	KeyLocator
	KeyDescriptor
	SignDescriptor
	SignReq
	SignResp
	InputScript
	InputScriptResp
	SignMessageReq
	SignMessageResp
	ComputeInputScriptReq
	ComputeInputScriptResp
	DerivePublicKeyReq
	DerivePublicKeyResp
*/
package hwwallet

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type OutPoint struct {
	Hash  []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	Index uint32 `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
}

func (m *OutPoint) Reset()                    { *m = OutPoint{} }
func (m *OutPoint) String() string            { return proto.CompactTextString(m) }
func (*OutPoint) ProtoMessage()               {}
func (*OutPoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *OutPoint) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *OutPoint) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type TxIn struct {
	PreviousOutPoint *OutPoint `protobuf:"bytes,1,opt,name=previousOutPoint" json:"previousOutPoint,omitempty"`
	SignatureScript  []byte    `protobuf:"bytes,2,opt,name=SignatureScript,json=signatureScript,proto3" json:"SignatureScript,omitempty"`
	Witness          []byte    `protobuf:"bytes,3,opt,name=witness,proto3" json:"witness,omitempty"`
	Sequence         uint32    `protobuf:"varint,4,opt,name=sequence" json:"sequence,omitempty"`
}

func (m *TxIn) Reset()                    { *m = TxIn{} }
func (m *TxIn) String() string            { return proto.CompactTextString(m) }
func (*TxIn) ProtoMessage()               {}
func (*TxIn) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TxIn) GetPreviousOutPoint() *OutPoint {
	if m != nil {
		return m.PreviousOutPoint
	}
	return nil
}

func (m *TxIn) GetSignatureScript() []byte {
	if m != nil {
		return m.SignatureScript
	}
	return nil
}

func (m *TxIn) GetWitness() []byte {
	if m != nil {
		return m.Witness
	}
	return nil
}

func (m *TxIn) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

type TxOut struct {
	Value    int64  `protobuf:"varint,1,opt,name=value" json:"value,omitempty"`
	PkScript []byte `protobuf:"bytes,2,opt,name=pk_script,json=pkScript,proto3" json:"pk_script,omitempty"`
}

func (m *TxOut) Reset()                    { *m = TxOut{} }
func (m *TxOut) String() string            { return proto.CompactTextString(m) }
func (*TxOut) ProtoMessage()               {}
func (*TxOut) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TxOut) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *TxOut) GetPkScript() []byte {
	if m != nil {
		return m.PkScript
	}
	return nil
}

type MsgTx struct {
	Version  int32    `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	TxIn     []*TxIn  `protobuf:"bytes,2,rep,name=txIn" json:"txIn,omitempty"`
	TxOut    []*TxOut `protobuf:"bytes,3,rep,name=txOut" json:"txOut,omitempty"`
	LockTime uint32   `protobuf:"varint,4,opt,name=lockTime" json:"lockTime,omitempty"`
}

func (m *MsgTx) Reset()                    { *m = MsgTx{} }
func (m *MsgTx) String() string            { return proto.CompactTextString(m) }
func (*MsgTx) ProtoMessage()               {}
func (*MsgTx) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *MsgTx) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *MsgTx) GetTxIn() []*TxIn {
	if m != nil {
		return m.TxIn
	}
	return nil
}

func (m *MsgTx) GetTxOut() []*TxOut {
	if m != nil {
		return m.TxOut
	}
	return nil
}

func (m *MsgTx) GetLockTime() uint32 {
	if m != nil {
		return m.LockTime
	}
	return 0
}

type SendOutputsRequest struct {
	// *
	// The number of satoshis per kilo weight that should be used when crafting
	// this transaction.
	SatPerKw int64 `protobuf:"varint,1,opt,name=sat_per_kw,json=satPerKw" json:"sat_per_kw,omitempty"`
	// *
	// A slice of the outputs that should be created in the transaction produced.
	Outputs []*TxOut `protobuf:"bytes,2,rep,name=outputs" json:"outputs,omitempty"`
}

func (m *SendOutputsRequest) Reset()                    { *m = SendOutputsRequest{} }
func (m *SendOutputsRequest) String() string            { return proto.CompactTextString(m) }
func (*SendOutputsRequest) ProtoMessage()               {}
func (*SendOutputsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SendOutputsRequest) GetSatPerKw() int64 {
	if m != nil {
		return m.SatPerKw
	}
	return 0
}

func (m *SendOutputsRequest) GetOutputs() []*TxOut {
	if m != nil {
		return m.Outputs
	}
	return nil
}

type SendOutputsResponse struct {
	// *
	// The serialized transaction sent out on the network.
	RawTx []byte `protobuf:"bytes,1,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
}

func (m *SendOutputsResponse) Reset()                    { *m = SendOutputsResponse{} }
func (m *SendOutputsResponse) String() string            { return proto.CompactTextString(m) }
func (*SendOutputsResponse) ProtoMessage()               {}
func (*SendOutputsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SendOutputsResponse) GetRawTx() []byte {
	if m != nil {
		return m.RawTx
	}
	return nil
}

type KeyLocator struct {
	// / The family of key being identified.
	KeyFamily uint32 `protobuf:"varint,1,opt,name=key_family,json=keyFamily" json:"key_family,omitempty"`
	// / The precise index of the key being identified.
	KeyIndex uint32 `protobuf:"varint,2,opt,name=key_index,json=keyIndex" json:"key_index,omitempty"`
}

func (m *KeyLocator) Reset()                    { *m = KeyLocator{} }
func (m *KeyLocator) String() string            { return proto.CompactTextString(m) }
func (*KeyLocator) ProtoMessage()               {}
func (*KeyLocator) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *KeyLocator) GetKeyFamily() uint32 {
	if m != nil {
		return m.KeyFamily
	}
	return 0
}

func (m *KeyLocator) GetKeyIndex() uint32 {
	if m != nil {
		return m.KeyIndex
	}
	return 0
}

type KeyDescriptor struct {
	// *
	// The raw bytes of the key being identified. Either this or the KeyLocator
	// must be specified.
	RawKeyBytes []byte `protobuf:"bytes,1,opt,name=raw_key_bytes,json=rawKeyBytes,proto3" json:"raw_key_bytes,omitempty"`
	// *
	// The key locator that identifies which key to use for signing. Either this
	// or the raw bytes of the target key must be specified.
	KeyLoc *KeyLocator `protobuf:"bytes,2,opt,name=key_loc,json=keyLoc" json:"key_loc,omitempty"`
}

func (m *KeyDescriptor) Reset()                    { *m = KeyDescriptor{} }
func (m *KeyDescriptor) String() string            { return proto.CompactTextString(m) }
func (*KeyDescriptor) ProtoMessage()               {}
func (*KeyDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *KeyDescriptor) GetRawKeyBytes() []byte {
	if m != nil {
		return m.RawKeyBytes
	}
	return nil
}

func (m *KeyDescriptor) GetKeyLoc() *KeyLocator {
	if m != nil {
		return m.KeyLoc
	}
	return nil
}

type SignDescriptor struct {
	// *
	// A descriptor that precisely describes *which* key to use for signing. This
	// may provide the raw public key directly, or require the Signer to re-derive
	// the key according to the populated derivation path.
	KeyDesc *KeyDescriptor `protobuf:"bytes,1,opt,name=key_desc,json=keyDesc" json:"key_desc,omitempty"`
	// *
	// A scalar value that will be added to the private key corresponding to the
	// above public key to obtain the private key to be used to sign this input.
	// This value is typically derived via the following computation:
	//
	// derivedKey = privkey + sha256(perCommitmentPoint || pubKey) mod N
	SingleTweak []byte `protobuf:"bytes,2,opt,name=single_tweak,json=singleTweak,proto3" json:"single_tweak,omitempty"`
	// *
	// A private key that will be used in combination with its corresponding
	// private key to derive the private key that is to be used to sign the target
	// input. Within the Lightning protocol, this value is typically the
	// commitment secret from a previously revoked commitment transaction. This
	// value is in combination with two hash values, and the original private key
	// to derive the private key to be used when signing.
	//
	// k = (privKey*sha256(pubKey || tweakPub) +
	// tweakPriv*sha256(tweakPub || pubKey)) mod N
	DoubleTweak []byte `protobuf:"bytes,3,opt,name=double_tweak,json=doubleTweak,proto3" json:"double_tweak,omitempty"`
	// *
	// The full script required to properly redeem the output.  This field will
	// only be populated if a p2wsh or a p2sh output is being signed.
	WitnessScript []byte `protobuf:"bytes,4,opt,name=witness_script,json=witnessScript,proto3" json:"witness_script,omitempty"`
	// *
	// A description of the output being spent. The value and script MUST be provided.
	Output *TxOut `protobuf:"bytes,5,opt,name=output" json:"output,omitempty"`
	// *
	// The target sighash type that should be used when generating the final
	// sighash, and signature.
	Sighash uint32 `protobuf:"varint,7,opt,name=sighash" json:"sighash,omitempty"`
	// *
	// The target input within the transaction that should be signed.
	InputIndex int32 `protobuf:"varint,8,opt,name=input_index,json=inputIndex" json:"input_index,omitempty"`
}

func (m *SignDescriptor) Reset()                    { *m = SignDescriptor{} }
func (m *SignDescriptor) String() string            { return proto.CompactTextString(m) }
func (*SignDescriptor) ProtoMessage()               {}
func (*SignDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SignDescriptor) GetKeyDesc() *KeyDescriptor {
	if m != nil {
		return m.KeyDesc
	}
	return nil
}

func (m *SignDescriptor) GetSingleTweak() []byte {
	if m != nil {
		return m.SingleTweak
	}
	return nil
}

func (m *SignDescriptor) GetDoubleTweak() []byte {
	if m != nil {
		return m.DoubleTweak
	}
	return nil
}

func (m *SignDescriptor) GetWitnessScript() []byte {
	if m != nil {
		return m.WitnessScript
	}
	return nil
}

func (m *SignDescriptor) GetOutput() *TxOut {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *SignDescriptor) GetSighash() uint32 {
	if m != nil {
		return m.Sighash
	}
	return 0
}

func (m *SignDescriptor) GetInputIndex() int32 {
	if m != nil {
		return m.InputIndex
	}
	return 0
}

type SignReq struct {
	// / The raw bytes of the transaction to be signed.
	RawTxBytes []byte `protobuf:"bytes,1,opt,name=raw_tx_bytes,json=rawTxBytes,proto3" json:"raw_tx_bytes,omitempty"`
	// / A set of sign descriptors, for each input to be signed.
	SignDescs []*SignDescriptor `protobuf:"bytes,2,rep,name=sign_descs,json=signDescs" json:"sign_descs,omitempty"`
}

func (m *SignReq) Reset()                    { *m = SignReq{} }
func (m *SignReq) String() string            { return proto.CompactTextString(m) }
func (*SignReq) ProtoMessage()               {}
func (*SignReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *SignReq) GetRawTxBytes() []byte {
	if m != nil {
		return m.RawTxBytes
	}
	return nil
}

func (m *SignReq) GetSignDescs() []*SignDescriptor {
	if m != nil {
		return m.SignDescs
	}
	return nil
}

type SignResp struct {
	// *
	// A set of signatures realized in a fixed 64-byte format ordered in ascending
	// input order.
	RawSigs [][]byte `protobuf:"bytes,1,rep,name=raw_sigs,json=rawSigs,proto3" json:"raw_sigs,omitempty"`
}

func (m *SignResp) Reset()                    { *m = SignResp{} }
func (m *SignResp) String() string            { return proto.CompactTextString(m) }
func (*SignResp) ProtoMessage()               {}
func (*SignResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *SignResp) GetRawSigs() [][]byte {
	if m != nil {
		return m.RawSigs
	}
	return nil
}

type InputScript struct {
	// / The serializes witness stack for the specified input.
	Witness [][]byte `protobuf:"bytes,1,rep,name=witness,proto3" json:"witness,omitempty"`
	// **
	// The optional sig script for the specified witness that will only be set if
	// the input specified is a nested p2sh witness program.
	ScriptSig []byte `protobuf:"bytes,2,opt,name=script_sig,json=scriptSig,proto3" json:"script_sig,omitempty"`
}

func (m *InputScript) Reset()                    { *m = InputScript{} }
func (m *InputScript) String() string            { return proto.CompactTextString(m) }
func (*InputScript) ProtoMessage()               {}
func (*InputScript) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *InputScript) GetWitness() [][]byte {
	if m != nil {
		return m.Witness
	}
	return nil
}

func (m *InputScript) GetScriptSig() []byte {
	if m != nil {
		return m.ScriptSig
	}
	return nil
}

type InputScriptResp struct {
	// / The set of fully valid input scripts requested.
	InputScripts []*InputScript `protobuf:"bytes,1,rep,name=input_scripts,json=inputScripts" json:"input_scripts,omitempty"`
}

func (m *InputScriptResp) Reset()                    { *m = InputScriptResp{} }
func (m *InputScriptResp) String() string            { return proto.CompactTextString(m) }
func (*InputScriptResp) ProtoMessage()               {}
func (*InputScriptResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *InputScriptResp) GetInputScripts() []*InputScript {
	if m != nil {
		return m.InputScripts
	}
	return nil
}

type SignMessageReq struct {
}

func (m *SignMessageReq) Reset()                    { *m = SignMessageReq{} }
func (m *SignMessageReq) String() string            { return proto.CompactTextString(m) }
func (*SignMessageReq) ProtoMessage()               {}
func (*SignMessageReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type SignMessageResp struct {
	RawSigs [][]byte `protobuf:"bytes,1,rep,name=raw_sigs,json=rawSigs,proto3" json:"raw_sigs,omitempty"`
}

func (m *SignMessageResp) Reset()                    { *m = SignMessageResp{} }
func (m *SignMessageResp) String() string            { return proto.CompactTextString(m) }
func (*SignMessageResp) ProtoMessage()               {}
func (*SignMessageResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *SignMessageResp) GetRawSigs() [][]byte {
	if m != nil {
		return m.RawSigs
	}
	return nil
}

type ComputeInputScriptReq struct {
	RawTx    []byte          `protobuf:"bytes,1,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
	SignDesc *SignDescriptor `protobuf:"bytes,2,opt,name=sign_desc,json=signDesc" json:"sign_desc,omitempty"`
}

func (m *ComputeInputScriptReq) Reset()                    { *m = ComputeInputScriptReq{} }
func (m *ComputeInputScriptReq) String() string            { return proto.CompactTextString(m) }
func (*ComputeInputScriptReq) ProtoMessage()               {}
func (*ComputeInputScriptReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ComputeInputScriptReq) GetRawTx() []byte {
	if m != nil {
		return m.RawTx
	}
	return nil
}

func (m *ComputeInputScriptReq) GetSignDesc() *SignDescriptor {
	if m != nil {
		return m.SignDesc
	}
	return nil
}

type ComputeInputScriptResp struct {
	InputScript *InputScript `protobuf:"bytes,1,opt,name=input_script,json=inputScript" json:"input_script,omitempty"`
}

func (m *ComputeInputScriptResp) Reset()                    { *m = ComputeInputScriptResp{} }
func (m *ComputeInputScriptResp) String() string            { return proto.CompactTextString(m) }
func (*ComputeInputScriptResp) ProtoMessage()               {}
func (*ComputeInputScriptResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ComputeInputScriptResp) GetInputScript() *InputScript {
	if m != nil {
		return m.InputScript
	}
	return nil
}

type DerivePublicKeyReq struct {
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *DerivePublicKeyReq) Reset()                    { *m = DerivePublicKeyReq{} }
func (m *DerivePublicKeyReq) String() string            { return proto.CompactTextString(m) }
func (*DerivePublicKeyReq) ProtoMessage()               {}
func (*DerivePublicKeyReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *DerivePublicKeyReq) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type DerivePublicKeyResp struct {
	PublicKeyBytes []byte `protobuf:"bytes,1,opt,name=public_key_bytes,json=publicKeyBytes,proto3" json:"public_key_bytes,omitempty"`
}

func (m *DerivePublicKeyResp) Reset()                    { *m = DerivePublicKeyResp{} }
func (m *DerivePublicKeyResp) String() string            { return proto.CompactTextString(m) }
func (*DerivePublicKeyResp) ProtoMessage()               {}
func (*DerivePublicKeyResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *DerivePublicKeyResp) GetPublicKeyBytes() []byte {
	if m != nil {
		return m.PublicKeyBytes
	}
	return nil
}

func init() {
	proto.RegisterType((*OutPoint)(nil), "hwwallet.OutPoint")
	proto.RegisterType((*TxIn)(nil), "hwwallet.TxIn")
	proto.RegisterType((*TxOut)(nil), "hwwallet.TxOut")
	proto.RegisterType((*MsgTx)(nil), "hwwallet.MsgTx")
	proto.RegisterType((*SendOutputsRequest)(nil), "hwwallet.SendOutputsRequest")
	proto.RegisterType((*SendOutputsResponse)(nil), "hwwallet.SendOutputsResponse")
	proto.RegisterType((*KeyLocator)(nil), "hwwallet.KeyLocator")
	proto.RegisterType((*KeyDescriptor)(nil), "hwwallet.KeyDescriptor")
	proto.RegisterType((*SignDescriptor)(nil), "hwwallet.SignDescriptor")
	proto.RegisterType((*SignReq)(nil), "hwwallet.SignReq")
	proto.RegisterType((*SignResp)(nil), "hwwallet.SignResp")
	proto.RegisterType((*InputScript)(nil), "hwwallet.InputScript")
	proto.RegisterType((*InputScriptResp)(nil), "hwwallet.InputScriptResp")
	proto.RegisterType((*SignMessageReq)(nil), "hwwallet.SignMessageReq")
	proto.RegisterType((*SignMessageResp)(nil), "hwwallet.SignMessageResp")
	proto.RegisterType((*ComputeInputScriptReq)(nil), "hwwallet.ComputeInputScriptReq")
	proto.RegisterType((*ComputeInputScriptResp)(nil), "hwwallet.ComputeInputScriptResp")
	proto.RegisterType((*DerivePublicKeyReq)(nil), "hwwallet.DerivePublicKeyReq")
	proto.RegisterType((*DerivePublicKeyResp)(nil), "hwwallet.DerivePublicKeyResp")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for HwWallet service

type HwWalletClient interface {
	// *
	// SendOutputs is similar to the existing sendmany call in Bitcoind, and
	// allows the caller to create a transaction that sends to several outputs at
	// once. This is ideal when wanting to batch create a set of transactions.
	SendOutputs(ctx context.Context, in *SendOutputsRequest, opts ...grpc.CallOption) (*SendOutputsResponse, error)
	// *
	// SignOutputRaw is a method that can be used to generated a signature for a
	// set of inputs/outputs to a transaction. Each request specifies details
	// concerning how the outputs should be signed, which keys they should be
	// signed with, and also any optional tweaks. The return value is a fixed
	// 64-byte signature (the same format as we use on the wire in Lightning).
	//
	// If we are  unable to sign using the specified keys, then an error will be
	// returned.
	SignOutputRaw(ctx context.Context, in *SignReq, opts ...grpc.CallOption) (*SignResp, error)
	// *
	// ComputeInputScript generates a complete InputIndex for the passed
	// transaction with the signature as defined within the passed SignDescriptor.
	// This method should be capable of generating the proper input script for
	// both regular p2wkh output and p2wkh outputs nested within a regular p2sh
	// output.
	//
	// Note that when using this method to sign inputs belonging to the wallet,
	// the only items of the SignDescriptor that need to be populated are pkScript
	// in the TxOut field, the value in that same field, and finally the input
	// index.
	ComputeInputScript(ctx context.Context, in *ComputeInputScriptReq, opts ...grpc.CallOption) (*ComputeInputScriptResp, error)
	// SignMessage attempts to sign a target message with the private key that
	// corresponds to the passed public key. If the target private key is unable to
	// be found, then an error will be returned. The actual digest signed is the
	// double SHA-256 of the passed message.
	//
	// NOTE: This is a part of the MessageSigner interface.
	SignMessage(ctx context.Context, in *SignMessageReq, opts ...grpc.CallOption) (*SignMessageResp, error)
	DerivePublicKey(ctx context.Context, in *DerivePublicKeyReq, opts ...grpc.CallOption) (*DerivePublicKeyResp, error)
}

type hwWalletClient struct {
	cc *grpc.ClientConn
}

func NewHwWalletClient(cc *grpc.ClientConn) HwWalletClient {
	return &hwWalletClient{cc}
}

func (c *hwWalletClient) SendOutputs(ctx context.Context, in *SendOutputsRequest, opts ...grpc.CallOption) (*SendOutputsResponse, error) {
	out := new(SendOutputsResponse)
	err := grpc.Invoke(ctx, "/hwwallet.HwWallet/SendOutputs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hwWalletClient) SignOutputRaw(ctx context.Context, in *SignReq, opts ...grpc.CallOption) (*SignResp, error) {
	out := new(SignResp)
	err := grpc.Invoke(ctx, "/hwwallet.HwWallet/SignOutputRaw", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hwWalletClient) ComputeInputScript(ctx context.Context, in *ComputeInputScriptReq, opts ...grpc.CallOption) (*ComputeInputScriptResp, error) {
	out := new(ComputeInputScriptResp)
	err := grpc.Invoke(ctx, "/hwwallet.HwWallet/ComputeInputScript", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hwWalletClient) SignMessage(ctx context.Context, in *SignMessageReq, opts ...grpc.CallOption) (*SignMessageResp, error) {
	out := new(SignMessageResp)
	err := grpc.Invoke(ctx, "/hwwallet.HwWallet/SignMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hwWalletClient) DerivePublicKey(ctx context.Context, in *DerivePublicKeyReq, opts ...grpc.CallOption) (*DerivePublicKeyResp, error) {
	out := new(DerivePublicKeyResp)
	err := grpc.Invoke(ctx, "/hwwallet.HwWallet/DerivePublicKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for HwWallet service

type HwWalletServer interface {
	// *
	// SendOutputs is similar to the existing sendmany call in Bitcoind, and
	// allows the caller to create a transaction that sends to several outputs at
	// once. This is ideal when wanting to batch create a set of transactions.
	SendOutputs(context.Context, *SendOutputsRequest) (*SendOutputsResponse, error)
	// *
	// SignOutputRaw is a method that can be used to generated a signature for a
	// set of inputs/outputs to a transaction. Each request specifies details
	// concerning how the outputs should be signed, which keys they should be
	// signed with, and also any optional tweaks. The return value is a fixed
	// 64-byte signature (the same format as we use on the wire in Lightning).
	//
	// If we are  unable to sign using the specified keys, then an error will be
	// returned.
	SignOutputRaw(context.Context, *SignReq) (*SignResp, error)
	// *
	// ComputeInputScript generates a complete InputIndex for the passed
	// transaction with the signature as defined within the passed SignDescriptor.
	// This method should be capable of generating the proper input script for
	// both regular p2wkh output and p2wkh outputs nested within a regular p2sh
	// output.
	//
	// Note that when using this method to sign inputs belonging to the wallet,
	// the only items of the SignDescriptor that need to be populated are pkScript
	// in the TxOut field, the value in that same field, and finally the input
	// index.
	ComputeInputScript(context.Context, *ComputeInputScriptReq) (*ComputeInputScriptResp, error)
	// SignMessage attempts to sign a target message with the private key that
	// corresponds to the passed public key. If the target private key is unable to
	// be found, then an error will be returned. The actual digest signed is the
	// double SHA-256 of the passed message.
	//
	// NOTE: This is a part of the MessageSigner interface.
	SignMessage(context.Context, *SignMessageReq) (*SignMessageResp, error)
	DerivePublicKey(context.Context, *DerivePublicKeyReq) (*DerivePublicKeyResp, error)
}

func RegisterHwWalletServer(s *grpc.Server, srv HwWalletServer) {
	s.RegisterService(&_HwWallet_serviceDesc, srv)
}

func _HwWallet_SendOutputs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendOutputsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HwWalletServer).SendOutputs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hwwallet.HwWallet/SendOutputs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HwWalletServer).SendOutputs(ctx, req.(*SendOutputsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HwWallet_SignOutputRaw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HwWalletServer).SignOutputRaw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hwwallet.HwWallet/SignOutputRaw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HwWalletServer).SignOutputRaw(ctx, req.(*SignReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HwWallet_ComputeInputScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComputeInputScriptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HwWalletServer).ComputeInputScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hwwallet.HwWallet/ComputeInputScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HwWalletServer).ComputeInputScript(ctx, req.(*ComputeInputScriptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HwWallet_SignMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HwWalletServer).SignMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hwwallet.HwWallet/SignMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HwWalletServer).SignMessage(ctx, req.(*SignMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HwWallet_DerivePublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DerivePublicKeyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HwWalletServer).DerivePublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hwwallet.HwWallet/DerivePublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HwWalletServer).DerivePublicKey(ctx, req.(*DerivePublicKeyReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _HwWallet_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hwwallet.HwWallet",
	HandlerType: (*HwWalletServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendOutputs",
			Handler:    _HwWallet_SendOutputs_Handler,
		},
		{
			MethodName: "SignOutputRaw",
			Handler:    _HwWallet_SignOutputRaw_Handler,
		},
		{
			MethodName: "ComputeInputScript",
			Handler:    _HwWallet_ComputeInputScript_Handler,
		},
		{
			MethodName: "SignMessage",
			Handler:    _HwWallet_SignMessage_Handler,
		},
		{
			MethodName: "DerivePublicKey",
			Handler:    _HwWallet_DerivePublicKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hwwallet.proto",
}

func init() { proto.RegisterFile("hwwallet.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 908 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x56, 0xdb, 0x6e, 0xdb, 0x46,
	0x10, 0x85, 0x2d, 0xc9, 0xa2, 0x86, 0xba, 0xb8, 0x93, 0xb8, 0x55, 0xd4, 0x18, 0x51, 0x17, 0x30,
	0xaa, 0x02, 0x69, 0x1e, 0xd4, 0x2b, 0xf2, 0xd0, 0x02, 0x69, 0x10, 0xc4, 0x55, 0x5d, 0x1b, 0x2b,
	0x01, 0x79, 0x2a, 0x04, 0x4a, 0xda, 0xca, 0x0b, 0xc9, 0xe4, 0x8a, 0xbb, 0x34, 0xc5, 0x3f, 0xe8,
	0x0f, 0xf4, 0x17, 0xfa, 0x93, 0x7d, 0x09, 0x76, 0x97, 0x14, 0x29, 0xd3, 0xca, 0x1b, 0x67, 0xe6,
	0x70, 0xcf, 0xcc, 0x99, 0xb3, 0x94, 0xa0, 0x7d, 0x1b, 0xc7, 0xde, 0x7a, 0xcd, 0xd4, 0x2b, 0x11,
	0x06, 0x2a, 0x40, 0x27, 0x8b, 0xc9, 0xf7, 0xe0, 0x5c, 0x47, 0xea, 0x26, 0xe0, 0xbe, 0x42, 0x84,
	0xea, 0xad, 0x27, 0x6f, 0xbb, 0x47, 0xfd, 0xa3, 0x41, 0x93, 0x9a, 0x67, 0x7c, 0x0a, 0x35, 0xee,
	0x2f, 0xd8, 0xb6, 0x7b, 0xdc, 0x3f, 0x1a, 0xb4, 0xa8, 0x0d, 0xc8, 0x7f, 0x47, 0x50, 0x9d, 0x6c,
	0x2f, 0x7d, 0xfc, 0x05, 0x4e, 0x45, 0xc8, 0xee, 0x79, 0x10, 0xc9, 0xec, 0x18, 0xf3, 0xba, 0x3b,
	0xc4, 0x57, 0x3b, 0xce, 0xac, 0x42, 0x4b, 0x58, 0x1c, 0x40, 0x67, 0xcc, 0x97, 0xbe, 0xa7, 0xa2,
	0x90, 0x8d, 0xe7, 0x21, 0x17, 0xca, 0x10, 0x35, 0x69, 0x47, 0xee, 0xa7, 0xb1, 0x0b, 0xf5, 0x98,
	0x2b, 0x9f, 0x49, 0xd9, 0xad, 0x18, 0x44, 0x16, 0x62, 0x0f, 0x1c, 0xc9, 0x36, 0x11, 0xf3, 0xe7,
	0xac, 0x5b, 0x35, 0x5d, 0xee, 0x62, 0xf2, 0x1a, 0x6a, 0x93, 0xed, 0x75, 0xa4, 0xf4, 0x1c, 0xf7,
	0xde, 0x3a, 0x62, 0xa6, 0xbb, 0x0a, 0xb5, 0x01, 0x7e, 0x09, 0x0d, 0xb1, 0x9a, 0xca, 0x22, 0xb1,
	0x23, 0x56, 0x96, 0x91, 0xfc, 0x73, 0x04, 0xb5, 0x2b, 0xb9, 0x9c, 0x6c, 0x35, 0xf7, 0x3d, 0x0b,
	0x25, 0x0f, 0x7c, 0xf3, 0x7a, 0x8d, 0x66, 0x21, 0x12, 0xa8, 0xaa, 0xed, 0xa5, 0xdf, 0x3d, 0xee,
	0x57, 0x06, 0xee, 0xb0, 0x9d, 0xcf, 0xac, 0xd5, 0xa1, 0xa6, 0x86, 0x17, 0x50, 0x53, 0xba, 0x87,
	0x6e, 0xc5, 0x80, 0x3a, 0x45, 0xd0, 0x75, 0xa4, 0xa8, 0xad, 0xea, 0x31, 0xd6, 0xc1, 0x7c, 0x35,
	0xe1, 0x77, 0xbb, 0x31, 0xb2, 0x98, 0xfc, 0x05, 0x38, 0x66, 0xfe, 0xe2, 0x3a, 0x52, 0x22, 0x52,
	0x92, 0xea, 0xe9, 0xa4, 0xc2, 0xe7, 0x00, 0xd2, 0x53, 0x53, 0xc1, 0xc2, 0xe9, 0x2a, 0x4e, 0x07,
	0x73, 0xa4, 0xa7, 0x6e, 0x58, 0x38, 0x8a, 0xf1, 0x1b, 0xa8, 0x07, 0x16, 0x9f, 0x76, 0x57, 0x22,
	0xce, 0xea, 0xe4, 0x25, 0x3c, 0xd9, 0x3b, 0x5e, 0x8a, 0xc0, 0x97, 0x0c, 0xcf, 0xe0, 0x24, 0xf4,
	0xe2, 0xa9, 0xda, 0xa6, 0x8e, 0xa8, 0x85, 0x5e, 0x3c, 0xd9, 0x92, 0xf7, 0x00, 0x23, 0x96, 0xfc,
	0x11, 0xcc, 0x3d, 0x15, 0x84, 0x78, 0x0e, 0xb0, 0x62, 0xc9, 0xf4, 0x6f, 0xef, 0x8e, 0xaf, 0x13,
	0x03, 0x6c, 0xd1, 0xc6, 0x8a, 0x25, 0xef, 0x4c, 0x42, 0x2b, 0xac, 0xcb, 0x45, 0x0f, 0x39, 0x2b,
	0x96, 0x5c, 0x1a, 0x1b, 0xcd, 0xa0, 0x35, 0x62, 0xc9, 0x5b, 0x66, 0x17, 0x10, 0x84, 0x48, 0xa0,
	0xa5, 0x19, 0xf5, 0x1b, 0xb3, 0x44, 0x31, 0x99, 0x12, 0xbb, 0xa1, 0x17, 0x8f, 0x58, 0xf2, 0x46,
	0xa7, 0xf0, 0x5b, 0xa8, 0xeb, 0xfa, 0x3a, 0x98, 0x9b, 0xf3, 0xdc, 0xe1, 0xd3, 0x7c, 0xae, 0xbc,
	0x2f, 0x7a, 0xb2, 0x32, 0xcf, 0xe4, 0xdf, 0x63, 0x68, 0x6b, 0x8b, 0x15, 0x58, 0x86, 0xa0, 0x5b,
	0x98, 0x2e, 0x98, 0x9c, 0xa7, 0x66, 0xfd, 0x62, 0xef, 0x88, 0x1c, 0x4a, 0x35, 0x95, 0x0e, 0xf1,
	0x2b, 0x68, 0x4a, 0xee, 0x2f, 0xd7, 0x6c, 0xaa, 0x62, 0xe6, 0xad, 0x52, 0xb3, 0xb8, 0x36, 0x37,
	0xd1, 0x29, 0x0d, 0x59, 0x04, 0xd1, 0x6c, 0x07, 0xb1, 0x36, 0x75, 0x6d, 0xce, 0x42, 0x2e, 0xa0,
	0x9d, 0xba, 0x36, 0x33, 0x5d, 0xd5, 0x80, 0x5a, 0x69, 0x36, 0xf5, 0xfa, 0xd7, 0x70, 0x62, 0x57,
	0xd3, 0xad, 0x99, 0xf6, 0x4a, 0x9b, 0x4b, 0xcb, 0xda, 0x98, 0x92, 0x2f, 0xcd, 0xa5, 0xad, 0x1b,
	0x6d, 0xb3, 0x10, 0x5f, 0x80, 0xcb, 0x7d, 0x11, 0xa9, 0x54, 0x79, 0xc7, 0xd8, 0x16, 0x4c, 0xca,
	0x6a, 0xbf, 0x80, 0xba, 0x96, 0x85, 0xb2, 0x0d, 0xf6, 0xa1, 0x69, 0xf7, 0xbc, 0x27, 0x3a, 0x98,
	0x6d, 0x5b, 0xcd, 0x7f, 0x02, 0xd0, 0xf7, 0xd1, 0x48, 0x96, 0xd9, 0xa9, 0x9b, 0x37, 0xb5, 0xaf,
	0x2f, 0x6d, 0xc8, 0x34, 0x96, 0xe4, 0x02, 0x1c, 0xcb, 0x22, 0x05, 0x3e, 0x03, 0x47, 0xd3, 0x48,
	0xbe, 0xd4, 0x14, 0x15, 0x7d, 0x85, 0x43, 0x2f, 0x1e, 0xf3, 0xa5, 0x24, 0xef, 0xc0, 0xbd, 0xd4,
	0xad, 0x95, 0xef, 0x7a, 0x0a, 0xcc, 0xee, 0xfa, 0x39, 0x80, 0xa5, 0xd1, 0xc7, 0xa4, 0x4b, 0x68,
	0xd8, 0xcc, 0x98, 0x2f, 0xc9, 0x15, 0x74, 0x0a, 0xe7, 0x18, 0xd6, 0xd7, 0xd0, 0xb2, 0x42, 0x58,
	0x94, 0x3d, 0xd1, 0x1d, 0x9e, 0xe5, 0xdd, 0x17, 0xdf, 0x68, 0xf2, 0x3c, 0x90, 0xe4, 0xd4, 0x5a,
	0xe7, 0x8a, 0x49, 0xe9, 0x2d, 0x19, 0x65, 0x1b, 0xf2, 0xd2, 0x7e, 0xaf, 0x76, 0x99, 0x4f, 0x8f,
	0xc5, 0xe0, 0xec, 0xb7, 0xe0, 0x4e, 0x44, 0x8a, 0xed, 0x75, 0xb5, 0x39, 0x70, 0xb3, 0xf0, 0x07,
	0x68, 0xec, 0x64, 0x4e, 0xcd, 0x7d, 0x58, 0x65, 0x27, 0x53, 0x99, 0x50, 0xf8, 0xfc, 0x31, 0x1a,
	0x29, 0xf0, 0x67, 0x68, 0x16, 0x87, 0x4f, 0xdd, 0x7e, 0x60, 0x76, 0xb7, 0x30, 0x3b, 0x19, 0x00,
	0xbe, 0x65, 0x21, 0xbf, 0x67, 0x37, 0xd1, 0x6c, 0xcd, 0xe7, 0x23, 0x96, 0xe8, 0xbe, 0x11, 0xaa,
	0xc2, 0x53, 0xf6, 0x17, 0xa2, 0x41, 0xcd, 0x33, 0xf9, 0x15, 0x9e, 0x94, 0x90, 0x52, 0xe0, 0x00,
	0x4e, 0x85, 0x49, 0x94, 0x6e, 0x73, 0x5b, 0x64, 0x40, 0x63, 0xae, 0xe1, 0xff, 0xc7, 0xe0, 0xbc,
	0x8f, 0x3f, 0x98, 0x86, 0xf0, 0x77, 0x70, 0x0b, 0x9f, 0x22, 0x7c, 0x5e, 0x18, 0xbf, 0xf4, 0x01,
	0xec, 0x9d, 0x1f, 0xa8, 0xa6, 0xdf, 0xaf, 0x1f, 0xa1, 0xa5, 0x35, 0xb3, 0x69, 0xea, 0xc5, 0xf8,
	0xd9, 0xbe, 0x98, 0x94, 0x6d, 0x7a, 0xf8, 0x30, 0x25, 0x05, 0x7e, 0x00, 0x2c, 0xeb, 0x89, 0x2f,
	0x72, 0xe4, 0xa3, 0x4b, 0xed, 0xf5, 0x3f, 0x0d, 0x90, 0x02, 0xdf, 0x80, 0x5b, 0x70, 0x0f, 0x3e,
	0xd8, 0x6d, 0x6e, 0xb3, 0xde, 0xb3, 0x03, 0x15, 0x29, 0xf0, 0x4f, 0xe8, 0x3c, 0x90, 0xbb, 0x28,
	0x52, 0x79, 0x67, 0x45, 0x91, 0x1e, 0xd9, 0xd3, 0xec, 0xc4, 0xfc, 0x23, 0xf8, 0xee, 0x63, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x96, 0x90, 0x36, 0xa9, 0x23, 0x08, 0x00, 0x00,
}
